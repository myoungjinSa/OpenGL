#version 400 core

uniform mat4 worldMatrix;
uniform mat4 worldViewMatrix;
uniform mat4 projectionMatrix;

uniform vec3 cameraPosition;

uniform sampler2D shaderTexture;

struct lightSource
{
  vec4 position;
  vec4 diffuse;
  vec4 specular;
  float constantAttenuation, linearAttenuation, quadraticAttenuation;
  float spotCutoff, spotExponent;
  vec3 spotDirection;
};


vec4 scene_ambient = vec4(0.2, 0.2, 0.2, 1.0);

struct BaseLight{
	vec4 position;
	vec4 diffuse;
	vec4 specular;
};

struct Attenuation{
	float constantAttenuation;
	float linearAttenuation;
	float quadraticAttenuation;
};

struct PointLight{
	BaseLight baseLight;
	Attenuation attenuation;
};

struct SpotLight{
	BaseLight baseLight;
	Attenuation attenuation;
	float spotCutoff, spotExponent;
    vec3 spotDirection;
};

struct material
{
  vec4 diffuse;
  vec4 ambient;
  vec4 specular;
  float shininess;
};

uniform SpotLight g_SpotLight;
uniform PointLight g_PointLight;

uniform material g_Material;

in VS_OUT{
	vec4 worldPosition;
	vec3 varyingNormalDirection;
	vec2 UV;
}fs_in;

out vec4 out_color;


vec3 CalcPointLight(PointLight pointLight){
	vec3 normalDirection = normalize(fs_in.varyingNormalDirection);
	vec3 viewDirection = normalize(cameraPosition - fs_in.worldPosition.xyz);
	vec3 lightDirection;
	float attenuation;

	vec3 positionToLightSource = vec3(pointLight.baseLight.position - fs_in.worldPosition);
		float distance = length(positionToLightSource);
		lightDirection = normalize(positionToLightSource);
		attenuation = 1.0 / (pointLight.attenuation.constantAttenuation
							+ pointLight.attenuation.linearAttenuation * distance
							+ pointLight.attenuation.quadraticAttenuation * distance * distance);


	float lambertian =  max(0.0, dot(normalDirection, lightDirection));
	vec3 diffuseReflection = vec3(0.0, 0.0, 0.0);
	if(0.0 < lambertian){
		diffuseReflection =  attenuation * vec3(pointLight.baseLight.diffuse) * vec3(g_Material.diffuse) * lambertian;
	}

	vec3 specularReflection;
	if(dot(normalDirection, lightDirection) < 0.0){
		specularReflection = vec3(0.0, 0.0, 0.0);		//no specular reflection;
	}else{	//light source on the right side
		specularReflection = attenuation * vec3(pointLight.baseLight.diffuse) * vec3(g_Material.specular) 
		* pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)), g_Material.shininess);
	}

	return diffuseReflection + specularReflection;
};

vec3 CalcSpotLight(SpotLight spotLight){
	vec3 normalDirection = normalize(fs_in.varyingNormalDirection);
	vec3 viewDirection = normalize(cameraPosition - fs_in.worldPosition.xyz);
	vec3 lightDirection;
	float attenuation;

	vec3 positionToLightSource = vec3(spotLight.baseLight.position - fs_in.worldPosition);
		float distance = length(positionToLightSource);
		lightDirection = normalize(positionToLightSource);
		attenuation = 1.0 / (spotLight.attenuation.constantAttenuation
							+ spotLight.attenuation.linearAttenuation * distance
							+ spotLight.attenuation.quadraticAttenuation * distance * distance);

	if(spotLight.spotCutoff <= 90.0){
		float clampedCosine = max(0.0, dot(-lightDirection, spotLight.spotDirection));
		if(clampedCosine < cos(radians(spotLight.spotCutoff))) // outside of spotlight cone?
		{
			attenuation = 0.0;
		}else{
			attenuation = attenuation * pow(clampedCosine, spotLight.spotExponent);
		}
	}
	
	float lambertian =  max(0.0, dot(normalDirection, lightDirection));
	vec3 diffuseReflection = vec3(0.0, 0.0, 0.0);
	if(0.0 < lambertian){
		diffuseReflection =  attenuation * vec3(spotLight.baseLight.diffuse) * vec3(g_Material.diffuse) * lambertian;
	}

	vec3 specularReflection;
	if(dot(normalDirection, lightDirection) < 0.0){
		specularReflection = vec3(0.0, 0.0, 0.0);		//no specular reflection;
	}else{	//light source on the right side
		specularReflection = attenuation * vec3(spotLight.baseLight.diffuse) * vec3(g_Material.specular) 
		* pow(max(0.0, dot(reflect(-lightDirection, normalDirection), viewDirection)), g_Material.shininess);
	}
	return diffuseReflection + specularReflection;
};

void main(){
	vec3 ambientLighting = vec3(scene_ambient) * vec3(g_Material.ambient);
	
	vec3 pointLightColor = CalcPointLight(g_PointLight);
	vec3 spotLightColor = CalcSpotLight(g_SpotLight);//CalcPointLight(g_PointLight);

	vec4 textureColor = texture(shaderTexture, fs_in.UV);
	out_color = textureColor * vec4(ambientLighting + pointLightColor + spotLightColor, 1.0);

}
